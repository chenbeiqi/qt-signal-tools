#pragma once

#include "QtMetacallAdapter.h"

#include <QtCore/QEvent>
#include <QtCore/QVector>

/** QtCallbackProxy provides a way to connect Qt signals to QtCallback objects
 * or function objects (wrappers around functions such as std::tr1::function,
 * boost::function or std::function).
 * 
 * In Qt 5, this is supported natively using the new signal and slot syntax:
 * http://qt-project.org/wiki/New_Signal_Slot_Syntax .  This is especially useful
 * when combined with C++11's lambdas.
 *
 * QtCallbackProxy provides a way to simulate this under Qt 4 with C++03 by installing
 * a proxy object between the original sender of the signal and the receiver.  The proxy
 * receives the signal and then invokes the callback functor with the signal's arguments.
 *
 * Checking of signal and receiver argument types is done at runtime when setting up
 * a connection, as with normal signals and slots in Qt 4.
 *
 * Example usage, binding a signal with no arguments to a callback which invokes
 * a slot with one fixed argument:
 *
 *  MyObject receiver;
 *  QPushButton button;
 *  QtCallback callback(&receiver, SLOT(buttonClicked(int)));
 *  callback.bind(42);
 *  QtCallbackProxy::connectCallback(&button, SIGNAL(clicked(bool)), callback);
 *  button.click();
 *
 * Will invoke Receiver::buttonClicked(42)
 *
 * You can also use QtCallbackProxy to invoke callbacks when an object receives an event
 * (as opposed to emits a signal).  For example:
 *
 *   QtCallbackProxy::connectEvent(widget, QEvent::Enter,
 *     QtCallback(otherWidget, SLOT(setVisible(bool))).bind(true));
 *   QtCallbackProxy::connectEvent(widget, QEvent::Leave,
 *     QtCallback(otherWidget, SLOT(setVisible(bool))).bind(false));
 *
 * Will show 'otherWidget' when the mouse hovers over 'widget' and hide it otherwise.
 */
class QtCallbackProxy : public QObject
{
	// no Q_OBJECT macro here - see qt_metacall() re-implementation
	// below
	
	public:
		typedef bool (*EventFilterFunc)(QObject*,QEvent*);

		QtCallbackProxy(QObject* parent = 0);

		/** Set up a binding so that @p callback is invoked when
		 * @p sender emits @p signal.  If @p signal has default arguments,
		 * they must be specified.  eg. Use SLOT(clicked(bool)) for a button
		 * rather than SLOT(clicked()).
		 *
		 * The @p callback argument can be a QtCallback object or a function
		 * object (eg. std::tr1::function).
		 */
		void bind(QObject* sender, const char* signal, const QtMetacallAdapter& callback);

		/** Set up a binding so that @p callback is invoked when @p sender
		 * receives @p event.
		 */
		void bind(QObject* sender, QEvent::Type event, const QtMetacallAdapter& callback, EventFilterFunc filter = 0);

		void unbind(QObject* sender, const char* signal);

		void unbind(QObject* sender, QEvent::Type event);

		// re-implemented from QObject (this method is normally declared via the Q_OBJECT
		// macro and implemented by the code generated by moc)
		virtual int qt_metacall(QMetaObject::Call call, int methodId, void** arguments);

		/** Install a proxy which invokes @p callback when @p sender emits @p signal.
		 */
		static void connectCallback(QObject* sender, const char* signal, const QtMetacallAdapter& callback);

		static void disconnectCallbacks(QObject* sender, const char* signal);

		/** Install a proxy which invokes @p callback when @p sender receives @p event.
		 */
		static void connectEvent(QObject* sender, QEvent::Type event, const QtMetacallAdapter& callback, EventFilterFunc filter = 0);
		static void disconnectEvent(QObject* sender, QEvent::Type event);

		// re-implemented from QObject
		virtual bool eventFilter(QObject* watched, QEvent* event);

	private:
		struct Binding
		{
			Binding(QObject* _sender = 0, int _signalIndex = -1, const QtMetacallAdapter& _callback = QtMetacallAdapter())
				: sender(_sender)
				, signalIndex(_signalIndex)
				, callback(_callback)
			{}

			const char* paramType(int index) const
			{
				if (index >= paramTypes.count()) {
					return 0;
				}
				return paramTypes.at(index).constData();
			}

			QObject* sender;
			int signalIndex;
			QList<QByteArray> paramTypes;
			QtMetacallAdapter callback;
		};

		struct EventBinding
		{
			EventBinding(QObject* _sender = 0, QEvent::Type _type = QEvent::None, const QtMetacallAdapter& _callback = QtMetacallAdapter(),
			             EventFilterFunc _filter = 0)
				: sender(_sender)
				, eventType(_type)
				, filter(_filter)
				, callback(_callback)
			{}

			QObject* sender;
			QEvent::Type eventType;
			EventFilterFunc filter;
			QtMetacallAdapter callback;
		};

		const Binding* matchBinding(QObject* sender, int signalIndex) const;
		void failInvoke(const QString& error);

		static bool checkTypeMatch(const QtMetacallAdapter& callback, const QList<QByteArray>& paramTypes);

		QVector<Binding> m_bindings;
		QVector<EventBinding> m_eventBindings;
};

Q_DECLARE_METATYPE(QtCallbackProxy*)

